// @flow

import { addProblem,
  addBulkProblems,
  deleteProblemsFromSource,
  getProblemsforProjectEnvironment,
} from '@lagoon/commons/dist/api';
import { sendToLagoonLogs } from '@lagoon/commons/dist/logs';
import { generateProblemsWebhookEventName } from "./webhookHelpers";
const HARBOR_VULNERABILITY_SOURCE = 'Harbor';


export async function processHarborVulnerabilityList(
  WebhookRequestData,
  channelWrapperWebhooks
) {
    const { webhooktype, event, uuid, body } = WebhookRequestData;

    const {
      lagoonProjectId,
      lagoonProjectName,
      lagoonEnvironmentId,
      lagoonEnvironmentName,
      lagoonServiceName,
      vulnerabilities,
    } = body;

    //Let's get the existing problems before removing them ...
    const existingProblemSet = (
      await getProblemsforProjectEnvironment(
        lagoonEnvironmentName,
        lagoonProjectId
      )
    )
      .filter((e) => e.service == lagoonServiceName)
      .reduce((prev, current) => prev.concat([current.identifier]), []);

    await deleteProblemsFromSource(
      lagoonEnvironmentId,
      HARBOR_VULNERABILITY_SOURCE,
      lagoonServiceName
    );

    const BATCH_SIZE = 50; let groupedVulns = [];
    if (vulnerabilities) {
      for (let i = 0; i < vulnerabilities.length; i += BATCH_SIZE) {

        const problems = vulnerabilities.map(element => {
          return {
            environment: lagoonEnvironmentId,
            identifier: element.id,
            severity: element.severity.toUpperCase(),
            severityScore: null,
            source: HARBOR_VULNERABILITY_SOURCE,
            description: element.description,
            links: element.links.pop(),
            data: JSON.stringify(element),
            version: element.version,
            fixedVersion: element.fix_version,
            service: lagoonServiceName,
            associatedPackage: element.package
          };
        });

        groupedVulns.push(problems.slice(i, i + BATCH_SIZE));
      }
    }

    groupedVulns.forEach((problems) => {
      addBulkProblems({
        problems: problems
      })
      .then((response) => {
        Object.keys(response).forEach(element => {
          const problem = response[element];

          sendToLagoonLogs(
            'info',
            lagoonProjectName,
            uuid,
            generateProblemsWebhookEventName({
              source: 'harbor',
              severity: problem.severity.toUpperCase(),
              isNew: !existingProblemSet.includes(problem.id),
            }),
            {
              lagoonProjectId,
              lagoonProjectName,
              lagoonEnvironmentId,
              lagoonEnvironmentName,
              lagoonServiceName,
              severity: problem.severity.toUpperCase(),
              vulnerability: problem,
            },
            `New problem found for ${lagoonProjectName}:${lagoonEnvironmentName}:${lagoonServiceName}. Severity: ${problem.severity}. Description: ${problem.description}`
          );
        });
      })
      .catch((error) =>
        sendToLagoonLogs(
          'error',
          '',
          uuid,
          `${webhooktype}:${event}:problem_insert_error`,
          { data: body },
          `Error inserting bulk harbor problems for ${lagoonProjectId}:${lagoonEnvironmentId} -- ${error.message}`
        )
      );
    });
  }
